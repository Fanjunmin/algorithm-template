背包问题：
给定总体积V, 有N个背包, 每个背包有体积v_i, 价值w_i
1. 0-1背包问题 每个背包最多使用一次
2. 完全背包问题 每个背包有无限多个
3. 多重背包问题 背包i最多有s_i个
4. 分组背包 每组背包只能选择一个

#0-1背包问题
集合定义(状态表示): 在前i个物品中选择总体积不超过j的最大价值
集合划分(状态计算)：
1. 包含第i个物品, f(i, j) = f(i - 1, j - v_i) + w_i
2. 不包含第i个物品, f(i - 1, j)
f(i, j) = max(f(i - 1, j), f(i - 1, j - v_i) + w_i, for j - v_i >= 0, i < N, j < V

##优化
集合定义(状态表示): 在N个物品中选择总体积不超过j的最大价值
集合划分(状态计算):
1. 包含第i个物品, f(j) = f(j - v_i) + w_i
2. 不包含第i个物品, f(j)
f(j) = max(f(j), f(j - v_i) + w_i), for j - v_i >= 0, i < N, j < V

#完全背包问题
集合定义(状态表示): 在前i个物品中选择总体积不超过j的最大价值
集合划分(状态计算)：
1. 包含0个第i个物品, f(i, j) = f(i - 1, j)
2. 包含k个第i个物品, f(i, j) = f(i - 1, j - k * v_i) + k * w_i
f(i, j) = max(f(i - 1, j - k * v_i) + k * w_i), for j - k * v_i >= 0

##优化1
f(i, j) = max(f(i - 1, j), f(i, j - v_i) + w_i), for j - v_i >= 0
集合定义(状态表示): 在前i个物品中选择总体积不超过j的最大价值
集合划分(状态计算):
1. 包含0个第i个物品, f(i, j) = f(i - 1, j)
2. 包含k个第i个物品, f(i, j) = f(i - 1, j - k * v_i) + k * w_i
f(i, j) = max(f(i - 1, j), f(i, j - v_i) + w_i)

##优化2
f(j) = max(f(j), f(j - v_i) + w_i)
集合定义(状态表示): 在N个物品中选择总体积不超过j的最大价值
集合划分(状态计算):
1. 包含0个第i个物品, f(j) = f(j)
2. 包含k个第i个物品, f(j) = f(j - k * v_i) + k * w_i
f(j) = max(f(j), f(j - v_i) + w_i)

#多重背包问题
集合定义(状态表示): 在N个物品中选择总体积不超过j的所有的最大价值
集合划分(状态计算)：
1. 包含0个第i个物品, f(j) = f(j)
2. 包含k个第i个物品, f(j) = f(j - k * v_i) + k * w_i, for k <= s_i