#dp
1.1状态表示
1.1.1 集合 集合的定义, 以及满足的条件
1.1.2 属性 MAX, MIN, COUNT
1.2 状态计算 集合划分(不重不漏), 再根据属性计算

#for example: 
0-1背包问题
f(i, j) = max(f(i - 1, j), f(i - 1, j - v_i) + w_i, for j - v_i >= 0
集合定义: 在前i个物品中选择总体积不超过j的所有的选法
集合划分：
1. 包含第i个物品, f(i, j) = f(i - 1, j - v_i) + w_i
2. 不包含第i个物品, f(i - 1, j)

##优化
f(j) = max(f(j), f(j - v_i) + w_i)
集合定义: 在N个物品中选择总体积不超过j的所有选法
集合划分:
1. 包含第i个物品, f(j) = f(j - v_i) + w_i
2. 不包含第i个物品, f(j)

#完全背包问题
f(i, j) = max(f(i - 1, j - k * v_i) + k * w_i), for j - k * v_i >= 0
集合定义: 在前i个物品中选择总体积不超过j的所有的选法
集合划分：
1. 选0个第i个物品, f(i, j) = f(i - 1, j)
2. 选k个第i个物品, f(i, j) = f(i - 1, j - k * v_i) + k * w_i

##优化1
f(i, j) = max(f(i - 1, j), f(i, j - v_i) + w_i), for j - v_i >= 0
集合定义: 在前i个物品中选择总体积不超过j的所有的选法
集合划分:
1. 选0个第i个物品, f(i, j) = f(i - 1, j)
2. 选k个第i个物品, f(i, j) = f(i - 1, j - k * v_i) + k * w_i
f(i, j) = max(f(i - 1, j), f(i, j - v_i) + w_i)

##优化2
f(j) = max(f(j), f(j - v_i) + w_i)
集合定义: 在N个物品中选择总体积不超过j的所有选法
集合划分:
1. 选0个第i个物品, f(j) = f(j)
2. 选k个第i个物品, f(j) = f(j - k * v_i) + k * w_i
f(j) = max(f(j), f(j - v_i) + w_i)

#多重背包问题
f(i, j) = 
集合定义: 在前i个物品中选择总体积不超过j的所有的选法
集合划分：
1. 选0个第i个物品, f(i, j) = f(i - 1, j)
2. 选k个第i个物品, f(i, j) = f(i - 1, j - k * v_i) + k * w_i, for k <= s_i