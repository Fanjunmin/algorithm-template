数字三角形模型
1. acwing1015
1.1 状态表示f[i,j]
集合：从坐标(0,0)到(i,j)的路线
属性：MAX取最大值
1.2 状态计算
集合划分：原则：不重不漏
f[i,j]可以分为两个部分
(1). 从(i-1,j)走到(i,j)
(2). 从(i,j-1)走到(i,j)
因此转移方程为 f[i,j] = max(f[i-1][j], f[i][j-1]) + w(i,j)
1.3 注意
边界条件的计算, 当i=0或者j=0时

2. acwing1018
2.1 状态表示f[i,j]
条件：最大的步长为2N-1等价于只能往下或者往右移动
集合：从坐标(0,0)到(i,j)的路线
属性：MIN取最小值
2.2 状态计算
集合划分：原则：不重不漏
f[i,j]可以分为两个部分
(1). 从(i-1,j)走到(i,j)
(2). 从(i,j-1)走到(i,j)
因此转移方程为 f[i,j] = min(f[i-1][j], f[i][j-1]) + w(i,j)
2.3 注意
边界条件的计算, 当i=0或者j=0时

3. acwing1027
3.1 状态表示f[k,i1,i2]
集合：表示两次路径(0,0)->(i1, k-i1), (0,0)->(i2, k-i2)的最大值
属性：max最大值
3.2 状态计算
集合划分：原则：不重不漏
f[k,i1,i2]可以分为四个部分
(1). 第一次往下走, 第二次也往下走
    f[k1-1,i1-1,i2-1]->f[k,i1,i2]
(2).第一次往下走, 第二次往右走
    f[k1-1,i1-1,i2]->f[k,i1,i2]
(3).第一次往右走, 第二次往下走
    f[k1-1,i1,i2-1]->f[k,i1,i2]
(4).第一次往右走, 第二次也往右走
    f[k1-1,i1,i2]->f[k,i1,i2]
转移方程需要考虑路径节点重合的情况
当重合即i1==i2时, 只需要加w(i1, k-i1)
当不重合即i1!=i2时, 只需要加w(i1, k-i1)和w(i2,k-i2)
令w=w(i1, k-1-i1) or w(i1, k-1-i1)+w(i2,k-1-i2)
因此转移方程为:
f[k,i1,i2] = w + max{f[k1-1,i1-1,i2-1], f[k1-1,i1-1,i2], f[k1-1,i1,i2-1], f[k1-1,i1,i2]}
3.3 注意
边界条件, 可以将数组申请大一些(大1即可), 这样就能保证i1-1>=0

4. acwIng275
4.1 状态表示f[k,i1,i2]
集合：表示两次路径(0,0)->(i1, k-i1), (0,0)->(i2, k-i2)的最大值
属性：max最大值
3.2 状态计算
集合划分：原则：不重不漏
f[k,i1,i2]可以分为四个部分
(1). 第一次往下走, 第二次也往下走
    f[k1-1,i1-1,i2-1]->f[k,i1,i2]
(2).第一次往下走, 第二次往右走
    f[k1-1,i1-1,i2]->f[k,i1,i2]
(3).第一次往右走, 第二次往下走
    f[k1-1,i1,i2-1]->f[k,i1,i2]
(4).第一次往右走, 第二次也往右走
    f[k1-1,i1,i2]->f[k,i1,i2]
转移方程需要考虑路径节点重合的情况
当重合即i1==i2时, 只需要加w(i1, k-i1)
当不重合即i1!=i2时, 只需要加w(i1, k-i1)和w(i2,k-i2)
令w=w(i1, k-1-i1) or w(i1, k-1-i1)+w(i2,k-1-i2)
因此转移方程为:
f[k,i1,i2] = w + max{f[k1-1,i1-1,i2-1], f[k1-1,i1-1,i2], f[k1-1,i1,i2-1], f[k1-1,i1,i2]}
3.3 注意
边界条件, 可以将数组申请大一些(大1即可), 这样就能保证i1-1>=0

最长上升子序列模型
1. acwing1017
