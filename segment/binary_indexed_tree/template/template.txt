1.背景
对一个数组进行两类操作:
- 区间求和 O(n)
- 区间单点修改 O(1)
对于多次的修改 O(n^2)

2. 树状数组 binary_indexed_tree
- 区间求和 O(logn)
- 区间单点修改 O(logn)
对于多次的修改 O(nlogn)
2.1 前置知识
lowbit(x)操作, 表示非负整数二进制下最末尾的1以及后面的0构成的数值, 例如
x = 22 = (10110)_2
lowbit(x) = (10110) & (01010) = (10) = 2
公式 lowbit(x)=x&(~x+1)=x&-x

2.2 树状数组实现
对于数组序列a[N], 建立一个数组c[N], 其中c[x]保存序列a的区间[x-lowbit(x)+1, x]中所有数的和.
c[x]性质, 假设N=16
a[1~16]
(1) 每个节点c[x]的子节点个数等于lowbit(x)的位数
    x=12, lowbit(12)=4, 对应a的区间为[12-4+1, 12]=[9, 12]
    x=11, lowbit(11)=1, 对应a的区间为[11, 11]
    x=10, lowbit(10)=2, 对应a的区间为[10-2+1, 10]=[9, 10]
    x=9, lowbit(9)=1, 对应a的区间为[9,9]
(2) 对于除树根外的节点, c[x]的父节点是c[x+lowbit[x]]
    x=9->x=10->x=12
    x=11->x=12
(3) c[x]保存的是以它为根的子树中所有叶节点的和
(4) 树的深度为O(logN)

2.3 基本API
(1) 前缀和查询query(l, r)
ask(x) 对于节点x, 求和多个自区间的值[x-lowbit(x) + 1, x]
query(l, r) = ask[r] - ask[l-1]
(2) 单点修改 update(x, y)
对a[x]加上一个数y, 同时维护前缀和序列
只需要对节点x以及祖先节点更新c的值即可 
c[x+lowbit(x)] += y
(3) 初始化init
可以借助单点修改来进行初始化, 首先构造一个全0的数组
对x执行 update(x, a[x])即可

